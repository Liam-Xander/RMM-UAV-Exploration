# RMM-UAV-Exploration

This repository will host the official implementation for our research on integrating the Random Mapping Method (RMM) into a complete UAV autonomous exploration system.

<p align="center">
  <img src="pics/RMM-UAV-Exploration.gif" width = "1000"/>
</p>

## Project Overview

Our research aims to leverage the high-fidelity, lightweight, and complete map representations generated by RMM to achieve more efficient and safer autonomous exploration for UAVs in complex environments. This work focuses on the first-ever integration of the RMM framework with a UAV exploration system for real-time, high-fidelity mapping.

The results of this work have been accepted for publication at IROS 2025.  
**Paper:** Xingyu Li, et al. "Real-Time Occupancy Grid Mapping Using RMM on Large-scale and Unstructured Environments," *2025 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)*.

Interested readers can watch the full video here: https://youtu.be/xtwMVSegKxE

## Research Methodology

### Problem Statement

Traditional occupancy mapping methods face critical limitations when applied to large-scale UAV exploration:

1. **Storage and Efficiency Bottleneck**: Conventional approaches (e.g., voxel grids, Bayesian filters) require storing the state (occupied, free, or unknown) of every single grid cell in the map. As the environment scales or resolution increases, memory consumption and query time grow exponentially, which is prohibitive for resource-constrained UAV platforms.

2. **Incomplete Map Problem**: Traditional methods relying on Bayesian filters can only update regions that are directly observed by sensors. Areas occluded by walls or obstacles must be marked as "unknown", resulting in maps full of gaps and holes that severely compromise path planning safety and efficiency.

### Random Mapping Method (RMM) Framework

To address these challenges, we propose a novel mapping framework based on the **Random Mapping Method (RMM)**. The core insight is to **transform the complex nonlinear mapping problem into a simple high-dimensional linear optimization problem**.

RMM can be understood as a specialized form of Extreme Learning Machine (ELM), where **only the final layer weights are trainable**. This is achieved through two stages:

**1. High-Dimensional Feature Mapping (Fixed)**:
- **Purpose**: Transform linearly inseparable "occupied" and "free" points in 3D space into linearly separable features.
- **Operation**: A randomly generated, **fixed** weight matrix `W` is used to map a 3D coordinate `x` to a high-dimensional feature space via `s = g(Wx)`, where `g` is a nonlinear activation function (e.g., sin).
- **Key Property**: `W` is initialized once and **never updated** during training.

**2. Linear Model Learning (Trainable)**:
- **Purpose**: Find a hyperplane in the high-dimensional feature space to separate occupied from free regions.
- **Operation**: The model only learns a small weight vector `β` (e.g., 200 dimensions), computing predictions via $\beta^T s$.
- **Key Property**: `β` is the **only trainable parameter** in the entire model.

### Real-Time Online Learning

RMM's efficiency stems from its simple computational structure:

**Forward Pass (Real-Time Prediction)**:
- For any query point `x`, the occupancy probability is computed as $P = \sigma(\beta^T g(Wx))$, where $\sigma$ is the sigmoid function.
- This is a pure mathematical computation with **no searching**, enabling **real-time map queries** on resource-constrained hardware.

**Backward Pass (Real-Time Learning)**:
- When new sensor data arrives (providing occupancy labels `t` for observed points), the model updates using stochastic gradient descent (SGD).
- Traditional neural networks require backpropagating through all layers, but RMM **only updates `β`**.
- The gradient computation for the mean squared error loss $J=(t - P)^2$ is **extremely lightweight**, allowing updates in real time during flight.

### Key Contributions

RMM achieves three decisive advantages:

1. **Lightweight Storage**: Instead of storing millions of voxel states, RMM only stores the weight vector `β` and the random seed for `W`. Storage overhead is constant and **independent of map size and resolution**.

2. **Real-Time Efficiency**: Both forward prediction and backward learning have minimal computational complexity, perfectly suitable for real-time autonomous exploration.

3. **Map Completion and Inference**: Most importantly, RMM learns a **continuous function** capturing spatial structure and patterns of the environment. This enables **generalization and inference** to unobserved regions. When encountering sensor blind spots, RMM can **automatically complete** the map based on learned patterns (e.g., "walls are usually continuous"), generating **complete and coherent** maps that serve as a reliable foundation for path planning and symbolic reasoning.

**In Summary**: By transforming occupancy mapping from a "storage-intensive" task into a "compute-intensive" online learning problem with minimal computation, RMM successfully achieves **lightweight storage**, **real-time online learning**, and **map completion** simultaneously on resource-limited UAV platforms.

## Core Implementation

Our implementation builds on top of the **FUEL** framework. The RMM-based mapping system is primarily implemented in the `plan_env` package, which extends the original SDF mapping capabilities with RMM functionality. Key components include:

### Core Algorithm Files
- **`random_mapping_method.cpp`**: CPU implementation of the RMM core logic, including feature mapping, training, and prediction functions.
- **`random_mapping_cuda.cu`**: CUDA-accelerated implementation for GPU-based high-performance computing, supporting real-time feature mapping, training, and inference.
- **`random_mapping_method.h`**: Class definition for the RMM module, declaring training and prediction interfaces.

### Integration Layer
- **`sdf_map.cpp`**: Extends a standard SDF map with RMM integration, enabling online training using sensor data and real-time occupancy prediction for map completion.
- **`map_ros.cpp`**: ROS wrapper for the SDF map, handling sensor data subscription and visualization of RMM predictions.

### Key Features
- **High-dimensional feature mapping** using fixed random weights and sin activation functions
- **Online learning** of linear model parameters via gradient descent
- **Real-time occupancy inference** for map completion in unobserved areas
- **CUDA acceleration** for efficient parallel computation on GPUs

## Usage

To run the autonomous exploration system, you will need two terminals.

1.  In the first terminal, launch the RViz visualization environment:

    ```bash
    roslaunch exploration_manager rviz.launch
    ```

2.  In the second terminal, start the main exploration node which includes the mapping and planning modules:

    ```bash
    roslaunch exploration_manager exploration.launch
    ```
    
## Contact

For any questions, please feel free to email [2300902@stu.neu.edu.cn].

