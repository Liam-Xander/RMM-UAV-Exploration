/*
 * @brief ROS wrapper for the SDF Map with RMM integration.
 *
 * This file serves as the ROS interface for the SDF map, with a special focus
 * on its integration with the Random Mapping Method (RMM).
 * Its RMM-related responsibilities include:
 *
 * 1.  Setting up ROS publishers to visualize the predicted occupancy points
 *     generated by the RMM, enabling real-time map completion visualization.
 * 2.  Receiving and preprocessing sensor data (e.g., global point clouds),
 *     which is then forwarded to the `SDFMap` object to serve as the input
 *     for the online training of the RMM.
 */
#include <plan_env/sdf_map.h>
#include <plan_env/map_ros.h>

#include <pcl/point_cloud.h>
#include <pcl/point_types.h>
#include <visualization_msgs/Marker.h>

#include <fstream>

#include <ros/ros.h>  
#include <pcl/octree/octree_search.h>
#include <pcl/features/normal_3d.h>
#include <pcl/filters/voxel_grid.h>

#include <pcl/filters/statistical_outlier_removal.h>
namespace fast_planner {
MapROS::MapROS() {
}

MapROS::~MapROS() {
}

void MapROS::setMap(SDFMap* map) {
  this->map_ = map;
}

// Initialize publishers.
void MapROS::init() {
  node_.param("map_ros/fx", fx_, -1.0);
  node_.param("map_ros/fy", fy_, -1.0);
  node_.param("map_ros/cx", cx_, -1.0);
  node_.param("map_ros/cy", cy_, -1.0);
  node_.param("map_ros/depth_filter_maxdist", depth_filter_maxdist_, -1.0);
  node_.param("map_ros/depth_filter_mindist", depth_filter_mindist_, -1.0);
  node_.param("map_ros/depth_filter_margin", depth_filter_margin_, -1);
  node_.param("map_ros/k_depth_scaling_factor", k_depth_scaling_factor_, -1.0);
  node_.param("map_ros/skip_pixel", skip_pixel_, -1);

  node_.param("map_ros/esdf_slice_height", esdf_slice_height_, -0.1);
  node_.param("map_ros/visualization_truncate_height", visualization_truncate_height_, -0.1);
  node_.param("map_ros/visualization_truncate_low", visualization_truncate_low_, -0.1);
  node_.param("map_ros/show_occ_time", show_occ_time_, false);
  node_.param("map_ros/show_esdf_time", show_esdf_time_, false);
  node_.param("map_ros/show_all_map", show_all_map_, false);
  node_.param("map_ros/frame_id", frame_id_, string("world"));
  node_.param("sdf_map/blue_region_z", blue_region_z_, -0.1);


  node_.param("/map_bounds/mmin_x", x_min, 1.0);
  node_.param("/map_bounds/mmin_y", y_min, 1.0);
  node_.param("/map_bounds/mmax_x", x_max, 1.0);
  node_.param("/map_bounds/mmax_y", y_max, 1.0);

  // std::cout << "/map_bounds/mmin_x: " << x_min << std::endl;
  // std::cout << "/map_bounds/mmin_y: " << y_min << std::endl;
  // std::cout << "/map_bounds/mmax_x: " << x_max << std::endl;
  // std::cout << "/map_bounds/mmax_y: " << y_max << std::endl;

/*----------------------*/
  // ms_->setMapROS(this);
  // ms_->nh = node_;
  // ms_->initMap();
/*----------------------*/

  proj_points_.resize(640 * 480 / (skip_pixel_ * skip_pixel_));
  point_cloud_.points.resize(640 * 480 / (skip_pixel_ * skip_pixel_));
  // proj_points_.reserve(640 * 480 / map_->mp_->skip_pixel_ / map_->mp_->skip_pixel_);
  proj_points_cnt = 0;

  local_updated_ = false;
  esdf_need_update_ = false;
  fuse_time_ = 0.0;
  esdf_time_ = 0.0;
  max_fuse_time_ = 0.0;
  max_esdf_time_ = 0.0;
  fuse_num_ = 0;
  esdf_num_ = 0;
  depth_image_.reset(new cv::Mat);

  rand_noise_ = normal_distribution<double>(0, 0.1);
  random_device rd;
  eng_ = default_random_engine(rd());

// Subscribe to the global obstacle point cloud
  global_map_sub = 
      node_.subscribe<sensor_msgs::PointCloud2>( "global_map", 5,  &MapROS::rcvGlobalPointCloudCallBack, this);


  esdf_timer_ = node_.createTimer(ros::Duration(0.05), &MapROS::updateESDFCallback, this);
  vis_timer_ = node_.createTimer(ros::Duration(0.05), &MapROS::visCallback, this);


  intersection_cloud_pub = node_.advertise<sensor_msgs::PointCloud2>("/intersection_cloud", 10);
  // map_pub_predict = node_.advertise<sensor_msgs::PointCloud2>("/map_pub_predict", 10);
  map_pub_boundary_expand = node_.advertise<sensor_msgs::PointCloud2>("/expand_origin_inflate_all_map", 5);
  map_pub_predict = node_.advertise<sensor_msgs::PointCloud2>("/map_pub_predict", 10);

  map_all_pub_ = node_.advertise<sensor_msgs::PointCloud2>("/sdf_map/occupancy_all", 10);
  map_local_pub_ = node_.advertise<sensor_msgs::PointCloud2>("/sdf_map/occupancy_local", 10);
  map_local_inflate_pub_ =
      node_.advertise<sensor_msgs::PointCloud2>("/sdf_map/occupancy_local_inflate", 10);
  unknown_pub_ = node_.advertise<sensor_msgs::PointCloud2>("/sdf_map/unknown", 10);
  esdf_pub_ = node_.advertise<sensor_msgs::PointCloud2>("/sdf_map/esdf", 10);
  update_range_pub_ = node_.advertise<visualization_msgs::Marker>("/sdf_map/update_range", 10);
  depth_pub_ = node_.advertise<sensor_msgs::PointCloud2>("/sdf_map/depth_cloud", 10);

  depth_sub_.reset(new message_filters::Subscriber<sensor_msgs::Image>(node_, "/map_ros/depth", 50));
  cloud_sub_.reset(
      new message_filters::Subscriber<sensor_msgs::PointCloud2>(node_, "/map_ros/cloud", 50));
  pose_sub_.reset(
      new message_filters::Subscriber<geometry_msgs::PoseStamped>(node_, "/map_ros/pose", 25));

  sync_image_pose_.reset(new message_filters::Synchronizer<MapROS::SyncPolicyImagePose>(
      MapROS::SyncPolicyImagePose(100), *depth_sub_, *pose_sub_));
  sync_image_pose_->registerCallback(boost::bind(&MapROS::depthPoseCallback, this, _1, _2));
  sync_cloud_pose_.reset(new message_filters::Synchronizer<MapROS::SyncPolicyCloudPose>(
      MapROS::SyncPolicyCloudPose(100), *cloud_sub_, *pose_sub_));
  sync_cloud_pose_->registerCallback(boost::bind(&MapROS::cloudPoseCallback, this, _1, _2));

  map_start_time_ = ros::Time::now();
}

void MapROS::publishPredictCloud(const pcl::PointCloud<pcl::PointXYZ>& cloud) {
    if (!map_pub_predict) {
        ROS_WARN("Predict cloud publisher not initialized!");
        return;
    } else {
        // std::cout << "Predict cloud publisher initialized!" << std::endl;
    }
    
    sensor_msgs::PointCloud2 cloud_msg;
    pcl::toROSMsg(cloud, cloud_msg);
    cloud_msg.header.frame_id = frame_id_;
    map_pub_predict.publish(cloud_msg);
}

// Trigger the publishMapAll() function.
void MapROS::visCallback(const ros::TimerEvent& e) {
  publishMapLocal();
  // When show_all_map_ is true, the timer will trigger the call of publishMapAll().
  if (show_all_map_) {
    static double tpass = 0.0;
    tpass += (e.current_real - e.last_real).toSec();
    if (tpass > 0.1) {
      publishMapAll();
      tpass = 0.0;
    }
  }
  // publishUnknown();
  // publishESDF();

  // publishUpdateRange();
  // publishDepth();
}

void MapROS::updateESDFCallback(const ros::TimerEvent& /*event*/) {
  if (!esdf_need_update_) return;
  auto t1 = ros::Time::now();

  map_->updateESDF3d();
  esdf_need_update_ = false;

  auto t2 = ros::Time::now();
  esdf_time_ += (t2 - t1).toSec();
  max_esdf_time_ = max(max_esdf_time_, (t2 - t1).toSec());
  esdf_num_++;
  if (show_esdf_time_)
    ROS_WARN("ESDF t: cur: %lf, avg: %lf, max: %lf", (t2 - t1).toSec(), esdf_time_ / esdf_num_,
             max_esdf_time_);
}

void MapROS::depthPoseCallback(const sensor_msgs::ImageConstPtr& img,
                               const geometry_msgs::PoseStampedConstPtr& pose) {
  camera_pos_(0) = pose->pose.position.x;
  camera_pos_(1) = pose->pose.position.y;
  camera_pos_(2) = pose->pose.position.z;
  if (!map_->isInMap(camera_pos_))  // exceed mapped region
    return;

  camera_q_ = Eigen::Quaterniond(pose->pose.orientation.w, pose->pose.orientation.x,
                                 pose->pose.orientation.y, pose->pose.orientation.z);
  cv_bridge::CvImagePtr cv_ptr = cv_bridge::toCvCopy(img, img->encoding);
  if (img->encoding == sensor_msgs::image_encodings::TYPE_32FC1)
    (cv_ptr->image).convertTo(cv_ptr->image, CV_16UC1, k_depth_scaling_factor_);
  cv_ptr->image.copyTo(*depth_image_);

  auto t1 = ros::Time::now();

  // generate point cloud, update map
  proessDepthImage();
  map_->inputPointCloud(point_cloud_, proj_points_cnt, camera_pos_);
  if (local_updated_) {
    map_->clearAndInflateLocalMap();
    esdf_need_update_ = true;
    local_updated_ = false;
  }

  auto t2 = ros::Time::now();
  fuse_time_ += (t2 - t1).toSec();
  max_fuse_time_ = max(max_fuse_time_, (t2 - t1).toSec());
  fuse_num_ += 1;
  if (show_occ_time_)
    ROS_WARN("Fusion t: cur: %lf, avg: %lf, max: %lf", (t2 - t1).toSec(), fuse_time_ / fuse_num_,
             max_fuse_time_);
}

void MapROS::cloudPoseCallback(const sensor_msgs::PointCloud2ConstPtr& msg,
                               const geometry_msgs::PoseStampedConstPtr& pose) {
  camera_pos_(0) = pose->pose.position.x;
  camera_pos_(1) = pose->pose.position.y;
  camera_pos_(2) = pose->pose.position.z;
  camera_q_ = Eigen::Quaterniond(pose->pose.orientation.w, pose->pose.orientation.x,
                                 pose->pose.orientation.y, pose->pose.orientation.z);
  pcl::PointCloud<pcl::PointXYZ> cloud;
  pcl::fromROSMsg(*msg, cloud);
  int num = cloud.points.size();

  map_->inputPointCloud(cloud, num, camera_pos_);

  if (local_updated_) {
    map_->clearAndInflateLocalMap();
    esdf_need_update_ = true;
    local_updated_ = false;
  }
}

void MapROS::proessDepthImage() {
  proj_points_cnt = 0;

  uint16_t* row_ptr;
  int cols = depth_image_->cols;
  int rows = depth_image_->rows;
  double depth;
  Eigen::Matrix3d camera_r = camera_q_.toRotationMatrix();
  Eigen::Vector3d pt_cur, pt_world;
  const double inv_factor = 1.0 / k_depth_scaling_factor_;

  for (int v = depth_filter_margin_; v < rows - depth_filter_margin_; v += skip_pixel_) {
    row_ptr = depth_image_->ptr<uint16_t>(v) + depth_filter_margin_;
    for (int u = depth_filter_margin_; u < cols - depth_filter_margin_; u += skip_pixel_) {
      depth = (*row_ptr) * inv_factor;
      row_ptr = row_ptr + skip_pixel_;

      // // filter depth
      // if (depth > 0.01)
      //   depth += rand_noise_(eng_);

      // TODO: simplify the logic here
      if (*row_ptr == 0 || depth > depth_filter_maxdist_)
        depth = depth_filter_maxdist_;
      else if (depth < depth_filter_mindist_)
        continue;

      pt_cur(0) = (u - cx_) * depth / fx_;
      pt_cur(1) = (v - cy_) * depth / fy_;
      pt_cur(2) = depth;
      pt_world = camera_r * pt_cur + camera_pos_;
      auto& pt = point_cloud_.points[proj_points_cnt++];
      pt.x = pt_world[0];
      pt.y = pt_world[1];
      pt.z = pt_world[2];
    }
  }

  publishDepth();
}

void MapROS::rcvGlobalPointCloudCallBack(const sensor_msgs::PointCloud2ConstPtr& msg) {
    // pcl::PointCloud<pcl::PointXYZ> cloudMap;

    pcl::fromROSMsg(*msg, cloudMap); 
    pcl::PointCloud<pcl::PointXYZ> inflatedCloud;

    pcl::PointCloud<pcl::PointXYZ> map_surface = intersectionpoints_surface_new(
        cloudMap, 
        min_cut_expand, 
        max_cut_expand
    );

    // Create a new point cloud to store the filtered results
    pcl::PointCloud<pcl::PointXYZ> filtered_map_surface;
// Use a HashSet to record the points that have been checked to avoid duplicate checks
std::unordered_set<int> checked_indices;

for (const auto& point : map_surface.points) {
    Eigen::Vector3i idx;
    map_->posToIndex(Eigen::Vector3d(point.x, point.y, point.z), idx);
    int index = map_->toAddress(idx.x(), idx.y(), idx.z());
    
    // If the point has been checked, skip it
    if (checked_indices.find(index) != checked_indices.end()) continue;
    
    bool has_occupied_neighbor = false;
    int search_radius = 3.0; 

    for(int dx = -search_radius; dx <= search_radius; ++dx) {
        for(int dy = -search_radius; dy <= search_radius; ++dy) {
            for(int dz = -search_radius; dz <= search_radius; ++dz) {
                Eigen::Vector3i neighbor_idx = idx + Eigen::Vector3i(dx, dy, dz);
                int neighbor_index = map_->toAddress(neighbor_idx.x(), neighbor_idx.y(), neighbor_idx.z());
                
                // Check and record the checked indices
                checked_indices.insert(neighbor_index);
                
                if(map_->isInMap(neighbor_idx) && 
                   map_->md_->occupancy_buffer_[neighbor_index] > map_->mp_->min_occupancy_log_) {
                    has_occupied_neighbor = true;
                    break;
                }
            }
            if(has_occupied_neighbor) break;
        }
        if(has_occupied_neighbor) break;
    }

    if(has_occupied_neighbor) {
        filtered_map_surface.points.push_back(point);
    }
}

    filtered_map_surface.width = filtered_map_surface.points.size();
    filtered_map_surface.height = 1;
    filtered_map_surface.is_dense = true;
    filtered_map_surface.header.frame_id = frame_id_;

    // Save the filtered results
    map_->map_surface_value = filtered_map_surface;

    // Publish the filtered point cloud
    sensor_msgs::PointCloud2 intersection_cloud_msg_expand_plus;
    pcl::toROSMsg(filtered_map_surface, intersection_cloud_msg_expand_plus);
    intersection_cloud_pub.publish(intersection_cloud_msg_expand_plus);

    // Print the message indicating that origin_map_occupancy_buffer_ has been updated
    // std::cout << "origin_map_occupancy_buffer_ has been updated" << std::endl;
    // ROS_WARN("origin_map_occupancy_buffer_ has been updated");
}

void MapROS::publishMapAll() {
  pcl::PointXYZ pt;
  pcl::PointCloud<pcl::PointXYZ> cloud1, cloud2;

  for (int x = map_->mp_->box_min_(0); x < map_->mp_->box_max_(0); ++x)
    for (int y = map_->mp_->box_min_(1); y < map_->mp_->box_max_(1); ++y)
      for (int z = map_->mp_->box_min_(2); z < map_->mp_->box_max_(2); ++z) {
        
        if (map_->md_->occupancy_buffer_[map_->toAddress(x, y, z)] > map_->mp_->min_occupancy_log_) {
          
          Eigen::Vector3d pos;
          map_->indexToPos(Eigen::Vector3i(x, y, z), pos);

          if (pos(0) < x_min || pos(0) > x_max ||
              pos(1) < y_min || pos(1) > y_max) {
            continue;  
          }

          const double z_offset = 0.1;  
          pos(2) += z_offset;
          if (pos(2) > visualization_truncate_height_ || pos(2) < visualization_truncate_low_) continue;

          // Add to point cloud
          pt.x = pos(0);
          pt.y = pos(1);
          pt.z = pos(2);
          cloud1.push_back(pt);

        }
      }

    pcl::PointCloud<pcl::PointXYZ> cumulative_cloud_boundary_expand;

    int lmm = map_->mp_->local_map_margin_;

    min_cut_expand = map_->md_->local_bound_min_;
    max_cut_expand = map_->md_->local_bound_max_;
    min_cut_expand(2) = map_->mp_->box_min_(2)-0.1; 
    max_cut_expand(2) = map_->mp_->box_max_(2)-0.1;  
    map_->boundIndex(min_cut_expand);
    map_->boundIndex(max_cut_expand);

    for (int x = min_cut_expand(0); x <= max_cut_expand(0); ++x)
        for (int y = min_cut_expand(1); y <= max_cut_expand(1); ++y)
            for (int z = min_cut_expand(2); z <= max_cut_expand(2); ++z) {
                
                    Eigen::Vector3d pos1;
                    map_->indexToPos(Eigen::Vector3i(x, y, z), pos1);
                    
                    if (pos1(2) > visualization_truncate_height_ || pos1(2) < visualization_truncate_low_) continue;

                    pcl::PointXYZ pt1;
                    pt1.x = pos1(0);
                    pt1.y = pos1(1);
                    pt1.z = pos1(2);

                    if (pos1(2) < blue_region_z_) {//map3 and map2
                        #pragma omp critical
                        cumulative_cloud_boundary_expand.push_back(pt1);
                    }
            }

    cumulative_cloud_boundary_expand.width = cumulative_cloud_boundary_expand.points.size();
    cumulative_cloud_boundary_expand.height = 1;
    cumulative_cloud_boundary_expand.is_dense = true;
    cumulative_cloud_boundary_expand.header.frame_id = frame_id_;
    sensor_msgs::PointCloud2 cloud_msg_expand;
    pcl::toROSMsg(cumulative_cloud_boundary_expand, cloud_msg_expand);
    map_pub_boundary_expand.publish(cloud_msg_expand);

  cloud1.width = cloud1.points.size();
  cloud1.height = 1;
  cloud1.is_dense = true;
  cloud1.header.frame_id = frame_id_;
  sensor_msgs::PointCloud2 cloud_msg;
  pcl::toROSMsg(cloud1, cloud_msg);
  map_all_pub_.publish(cloud_msg);

  double time_now = (ros::Time::now() - map_start_time_).toSec();
  double known_volumn = 0;
  for (int x = map_->mp_->box_min_(0); x < map_->mp_->box_max_(0); ++x)
    for (int y = map_->mp_->box_min_(1); y < map_->mp_->box_max_(1); ++y)
      for (int z = map_->mp_->box_min_(2); z < map_->mp_->box_max_(2); ++z) {
        if (map_->md_->occupancy_buffer_[map_->toAddress(x, y, z)] > map_->mp_->clamp_min_log_ - 1e-3)
          known_volumn += 0.1 * 0.1 * 0.1;
      }

  ofstream file("/home/boboyu/workspaces/plan_ws/src/fast_planner/exploration_manager/resource/"
                "curve1.txt",
                ios::app);
  file << "time:" << time_now << ",vol:" << known_volumn << std::endl;
}

void MapROS::publishMapLocal() {
  pcl::PointXYZ pt;
  pcl::PointCloud<pcl::PointXYZ> cloud;
  pcl::PointCloud<pcl::PointXYZ> cloud2;
  Eigen::Vector3i min_cut = map_->md_->local_bound_min_;
  Eigen::Vector3i max_cut = map_->md_->local_bound_max_;
  map_->boundIndex(min_cut);
  map_->boundIndex(max_cut);

  // for (int z = min_cut(2); z <= max_cut(2); ++z)
  for (int x = min_cut(0); x <= max_cut(0); ++x)
    for (int y = min_cut(1); y <= max_cut(1); ++y)
      for (int z = map_->mp_->box_min_(2); z < map_->mp_->box_max_(2); ++z) {
        if (map_->md_->occupancy_buffer_[map_->toAddress(x, y, z)] > map_->mp_->min_occupancy_log_) {
          // Occupied cells
          Eigen::Vector3d pos;
          map_->indexToPos(Eigen::Vector3i(x, y, z), pos);
          if (pos(2) > visualization_truncate_height_) continue;
          if (pos(2) < visualization_truncate_low_) continue;

          pt.x = pos(0);
          pt.y = pos(1);
          pt.z = pos(2);
          cloud.push_back(pt);
        }
      }

  cloud.width = cloud.points.size();
  cloud.height = 1;
  cloud.is_dense = true;
  cloud.header.frame_id = frame_id_;
  cloud2.width = cloud2.points.size();
  cloud2.height = 1;
  cloud2.is_dense = true;
  cloud2.header.frame_id = frame_id_;
  sensor_msgs::PointCloud2 cloud_msg;

  pcl::toROSMsg(cloud, cloud_msg);
  map_local_pub_.publish(cloud_msg);
  pcl::toROSMsg(cloud2, cloud_msg);
  map_local_inflate_pub_.publish(cloud_msg);
}

pcl::PointCloud<pcl::PointXYZ> MapROS::intersectionpoints(
    const pcl::PointCloud<pcl::PointXYZ>& cloudMap,
    const Eigen::Vector3i& min_cut,
    const Eigen::Vector3i& max_cut
) {
    pcl::PointCloud<pcl::PointXYZ> result;  

    for (const auto& point : cloudMap.points) {
        Eigen::Vector3i idx;
        map_->posToIndex(Eigen::Vector3d(point.x, point.y, point.z), idx);

        if (idx.x() >= min_cut.x() && idx.x() <= max_cut.x() &&
            idx.y() >= min_cut.y() && idx.y() <= max_cut.y() &&
            idx.z() >= min_cut.z() && idx.z() <= max_cut.z()) {
            result.push_back(point);
        }
    }

    return result;
}

pcl::PointCloud<pcl::PointXYZ> MapROS::intersectionpoints_surface_new(
    const pcl::PointCloud<pcl::PointXYZ>& cloudMap,
    const Eigen::Vector3i& min_cut,
    const Eigen::Vector3i& max_cut
) {
    // 1. Get the bounding box range
    Eigen::Vector3d min_bound, max_bound;
    map_->indexToPos(min_cut, min_bound);
    map_->indexToPos(max_cut, max_bound);

    // 2. Create 3D grid
    const float grid_size = 0.3f;  
    std::unordered_map<Eigen::Vector3i, std::vector<pcl::PointXYZ>, HashVector3i> grid_map;

    // 3. Put the point cloud into the grid
    for (const auto& pt : cloudMap.points) {
        if (pt.x >= min_bound.x() && pt.x <= max_bound.x() &&
            pt.y >= min_bound.y() && pt.y <= max_bound.y() &&
            pt.z >= min_bound.z() && pt.z <= max_bound.z()) {
            
            Eigen::Vector3i grid_idx(
                static_cast<int>(pt.x / grid_size),
                static_cast<int>(pt.y / grid_size),
                static_cast<int>(pt.z / grid_size)
            );
            grid_map[grid_idx].push_back(pt);
        }
    }

    // 4. Extract surface points
    pcl::PointCloud<pcl::PointXYZ> surface_points;
    
    const int min_points_in_grid = 3;      
    const int max_points_in_grid = 30;    
    
    std::vector<Eigen::Vector3i> neighbors;
    for(int dx = -1; dx <= 1; dx++) {
        for(int dy = -1; dy <= 1; dy++) {
            for(int dz = -1; dz <= 1; dz++) {
                if(dx == 0 && dy == 0 && dz == 0) continue;
                neighbors.push_back(Eigen::Vector3i(dx, dy, dz));
            }
        }
    }

    for (const auto& grid_pair : grid_map) {
        const auto& grid_idx = grid_pair.first;
        const auto& points = grid_pair.second;

        if (points.size() < min_points_in_grid || points.size() > max_points_in_grid) {
            continue;
        }

        // Calculate the density feature of the current grid
        Eigen::Vector3f centroid(0.0f, 0.0f, 0.0f);
        for (const auto& pt : points) {
            centroid += Eigen::Vector3f(pt.x, pt.y, pt.z);
        }
        centroid /= points.size();

        // Compute covariance matrix
        Eigen::Matrix3f covariance = Eigen::Matrix3f::Zero();
        for (const auto& pt : points) {
            Eigen::Vector3f p(pt.x, pt.y, pt.z);
            Eigen::Vector3f diff = p - centroid;
            covariance += diff * diff.transpose();
        }
        covariance /= points.size();

        // Compute eigenvalues
        Eigen::SelfAdjointEigenSolver<Eigen::Matrix3f> eigen_solver(covariance);
        Eigen::Vector3f eigenvalues = eigen_solver.eigenvalues();
        
        // Compute planarity
        float planarity = (eigenvalues(1) - eigenvalues(0)) / eigenvalues(2);
        
        // Check neighborhood distribution
        int empty_neighbors = 0;
        int occupied_neighbors = 0;
        float min_neighbor_dist = std::numeric_limits<float>::max();

        for (const auto& offset : neighbors) {
            Eigen::Vector3i neighbor_idx = grid_idx + offset;
            auto it = grid_map.find(neighbor_idx);
            
            if (it == grid_map.end()) {
                empty_neighbors++;
            } else {
                occupied_neighbors++;
                
                // Compute the centroid of the neighbor grid
                Eigen::Vector3f neighbor_centroid(0.0f, 0.0f, 0.0f);
                for (const auto& pt : it->second) {
                    neighbor_centroid += Eigen::Vector3f(pt.x, pt.y, pt.z);
                }
                neighbor_centroid /= it->second.size();
                
                float dist = (centroid - neighbor_centroid).norm();
                min_neighbor_dist = std::min(min_neighbor_dist, dist);
            }
        }

        // Improved surface point judgment conditions, // Planarity threshold 0.6, can be adjusted to obtain a more obvious surface
        bool has_planarity = planarity > 0.8f;
        bool has_good_neighbors = (empty_neighbors >= 4 && empty_neighbors <= 18) && 
                                (occupied_neighbors >= 8);
        bool has_good_density = min_neighbor_dist > grid_size * 0.3f && 
                              min_neighbor_dist < grid_size * 1.5f;

        // Comprehensive judgment
        if ((has_planarity && has_good_neighbors) || 
            (has_good_neighbors && has_good_density)) {
            for (const auto& pt : points) {
                surface_points.push_back(pt);
            }
        }
    }

    // 5. Post-process the results
    if (surface_points.size() > 0) {
        // Voxel filtering downsampling
        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);
        pcl::VoxelGrid<pcl::PointXYZ> voxel_filter;
        voxel_filter.setInputCloud(surface_points.makeShared());
        voxel_filter.setLeafSize(0.1f, 0.1f, 0.1f);
        voxel_filter.filter(*cloud_filtered);
        
        return *cloud_filtered;
    }

    return surface_points;
}

void MapROS::publishUnknown() {
  pcl::PointXYZ pt;
  pcl::PointCloud<pcl::PointXYZ> cloud;
  Eigen::Vector3i min_cut = map_->md_->local_bound_min_;
  Eigen::Vector3i max_cut = map_->md_->local_bound_max_;
  map_->boundIndex(max_cut);
  map_->boundIndex(min_cut);

  for (int x = min_cut(0); x <= max_cut(0); ++x)
    for (int y = min_cut(1); y <= max_cut(1); ++y)
      for (int z = min_cut(2); z <= max_cut(2); ++z) {
        if (map_->md_->occupancy_buffer_[map_->toAddress(x, y, z)] < map_->mp_->clamp_min_log_ - 1e-3) {
          Eigen::Vector3d pos;
          map_->indexToPos(Eigen::Vector3i(x, y, z), pos);
          if (pos(2) > visualization_truncate_height_) continue;
          if (pos(2) < visualization_truncate_low_) continue;
          pt.x = pos(0);
          pt.y = pos(1);
          pt.z = pos(2);
          cloud.push_back(pt);
        }
      }
  cloud.width = cloud.points.size();
  cloud.height = 1;
  cloud.is_dense = true;
  cloud.header.frame_id = frame_id_;
  sensor_msgs::PointCloud2 cloud_msg;
  pcl::toROSMsg(cloud, cloud_msg);
  unknown_pub_.publish(cloud_msg);
}

void MapROS::publishDepth() {
  pcl::PointXYZ pt;
  pcl::PointCloud<pcl::PointXYZ> cloud;
  for (int i = 0; i < proj_points_cnt; ++i) {
    cloud.push_back(point_cloud_.points[i]);
  }
  cloud.width = cloud.points.size();
  cloud.height = 1;
  cloud.is_dense = true;
  cloud.header.frame_id = frame_id_;
  sensor_msgs::PointCloud2 cloud_msg;
  pcl::toROSMsg(cloud, cloud_msg);
  depth_pub_.publish(cloud_msg);
}

void MapROS::publishUpdateRange() {
  Eigen::Vector3d esdf_min_pos, esdf_max_pos, cube_pos, cube_scale;
  visualization_msgs::Marker mk;
  map_->indexToPos(map_->md_->local_bound_min_, esdf_min_pos);
  map_->indexToPos(map_->md_->local_bound_max_, esdf_max_pos);

  cube_pos = 0.5 * (esdf_min_pos + esdf_max_pos);
  cube_scale = esdf_max_pos - esdf_min_pos;
  mk.header.frame_id = frame_id_;
  mk.header.stamp = ros::Time::now();
  mk.type = visualization_msgs::Marker::CUBE;
  mk.action = visualization_msgs::Marker::ADD;
  mk.id = 0;
  mk.pose.position.x = cube_pos(0);
  mk.pose.position.y = cube_pos(1);
  mk.pose.position.z = cube_pos(2);
  mk.scale.x = cube_scale(0);
  mk.scale.y = cube_scale(1);
  mk.scale.z = cube_scale(2);
  mk.color.a = 0.3;
  mk.color.r = 1.0;
  mk.color.g = 0.0;
  mk.color.b = 0.0;
  mk.pose.orientation.w = 1.0;
  mk.pose.orientation.x = 0.0;
  mk.pose.orientation.y = 0.0;
  mk.pose.orientation.z = 0.0;

  update_range_pub_.publish(mk);
}

void MapROS::publishESDF() {
  double dist;
  pcl::PointCloud<pcl::PointXYZI> cloud;
  pcl::PointXYZI pt;

  const double min_dist = 0.0;
  const double max_dist = 3.0;

  Eigen::Vector3i min_cut = map_->md_->local_bound_min_ - Eigen::Vector3i(map_->mp_->local_map_margin_,
                                                                          map_->mp_->local_map_margin_,
                                                                          map_->mp_->local_map_margin_);
  Eigen::Vector3i max_cut = map_->md_->local_bound_max_ + Eigen::Vector3i(map_->mp_->local_map_margin_,
                                                                          map_->mp_->local_map_margin_,
                                                                          map_->mp_->local_map_margin_);
  map_->boundIndex(min_cut);
  map_->boundIndex(max_cut);

  for (int x = min_cut(0); x <= max_cut(0); ++x)
    for (int y = min_cut(1); y <= max_cut(1); ++y) {
      Eigen::Vector3d pos;
      map_->indexToPos(Eigen::Vector3i(x, y, 1), pos);
      pos(2) = esdf_slice_height_;
      dist = map_->getDistance(pos);
      dist = min(dist, max_dist);
      dist = max(dist, min_dist);
      pt.x = pos(0);
      pt.y = pos(1);
      pt.z = -0.2;
      pt.intensity = (dist - min_dist) / (max_dist - min_dist);
      cloud.push_back(pt);
    }

  cloud.width = cloud.points.size();
  cloud.height = 1;
  cloud.is_dense = true;
  cloud.header.frame_id = frame_id_;
  sensor_msgs::PointCloud2 cloud_msg;
  pcl::toROSMsg(cloud, cloud_msg);

  esdf_pub_.publish(cloud_msg);

  // ROS_INFO("pub esdf");
}
}